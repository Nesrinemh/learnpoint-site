import * as path from "https://deno.land/std@0.79.0/path/mod.ts";
import { bold, yellow } from "https://deno.land/std@0.79.0/fmt/colors.ts";

const buildArgs = {};

export async function sideBuild(sourcePath, targetPath, componentsPath, forceRebuild = false) {
    buildArgs.componentsPath = componentsPath;
    buildArgs.forceRebuild = forceRebuild;
    buildArgs.componentsMTime = await getComponentsMTime();

    recursiveBuild(sourcePath, targetPath);
}

async function recursiveBuild(sourcePath, targetPath) {
    await Deno.mkdir(targetPath, { recursive: true });

    for await (const dirEntry of Deno.readDir(sourcePath)) {
        const sPath = path.join(sourcePath, dirEntry.name);
        const tPath = path.join(targetPath, dirEntry.name);

        if (sPath === buildArgs.componentsPath) {
            continue;
        }

        if (dirEntry.isDirectory) {
            recursiveBuild(sPath, tPath);
            continue;
        }

        const [buildNeeded, buildReason] = await isBuildNeeded(sPath, tPath)
        if (buildNeeded) {
            console.log('Building', path.relative(Deno.cwd(), tPath), '-', buildReason);
            buildFile(sPath, tPath);
        }
    }
}

async function getComponentsMTime() {
    let componentsMTime = new Date(0);

    for await (const item of Deno.readDir(buildArgs.componentsPath)) {
        const itemPath = path.join(buildArgs.componentsPath, item.name);
        const itemInfo = await Deno.lstat(itemPath);

        if (itemInfo.mtime > componentsMTime) {
            componentsMTime = itemInfo.mtime;
        }
    }
    return componentsMTime;
}

async function isBuildNeeded(sourceFilePath, targetFilePath) {
    if (buildArgs.forceRebuild) {
        return [true, 'Build forced'];
    }

    try {
        const [sourceFileInfo, targetFileInfo] = await Promise.all([
            Deno.stat(sourceFilePath),
            Deno.stat(targetFilePath),
        ]);

        if (sourceFileInfo.mtime > targetFileInfo.mtime) {
            return [true, 'File modified'];
        }

        if (isHtmlFile(sourceFilePath) && buildArgs.componentsMTime > targetFileInfo.mtime) {
            return [true, 'Components modified'];
        }
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return [true, 'New file'];
        } else {
            throw error;
        }
    }

    return [false, ''];
}

async function buildFile(sourceFilePath, targetFilePath) {
    if (isHtmlFile(sourceFilePath)) {
        const sourceContent = await Deno.readTextFile(sourceFilePath);
        Deno.writeTextFile(targetFilePath, renderHtmlFile(sourceContent, sourceFilePath));
    } else {
        Deno.copyFile(sourceFilePath, targetFilePath);
    }
}

const isHtmlFile = sourceFilePath => path.extname(sourceFilePath) === '.html';

const renderHtmlFile = (data, sourceFilePath) => {
    return data.toString().replace(/\[\[.*\]\]/g, match => {
        const [error, renderedContent] = renderComponent(match.replace('[[', '').replace(']]', ''));

        if (error) {
            console.log();
            console.log(bold(yellow('Error in:')), bold(yellow(path.relative(Deno.cwd(), sourceFilePath))));
            console.log(bold('=== >'), bold(error));
            console.log();
        }

        return renderedContent;
    });
};

const renderComponent = componentString => {
    let error = null;

    const componentName = componentString.split(',')[0].trim();
    const componentContent = Deno.readTextFileSync(path.join(buildArgs.componentsPath, componentName));

    let componentData = {};

    if (componentString.includes(',')) {
        const componentDataString = componentString.substring(componentString.indexOf(',') + 1).trim();
        try {
            componentData = eval(`(${componentDataString})`);

            if (componentData === null || typeof componentData !== 'object') {
                error = 'Component data is not a valid javascript object: ' + componentDataString;
                componentData = {};
            }
        } catch (err) {
            error = 'Component data is not valid javascript: ' + componentDataString;
            componentData = {};
        }
    }
    
    return [error, componentContent.replace(/{{.*}}/g, match => renderComponentData(match.replace('{{', '').replace('}}', ''), componentData))];
};

const renderComponentData = (componentDataString, componentData) => {
    let dataKey = componentDataString.split('||')[0].trim();

    if (componentData[dataKey]) {
        return componentData[dataKey];
    }

    if (componentDataString.includes('||')) {
        return componentDataString.substring(componentDataString.indexOf('||') + 2).trim();
    }

    return '';
};
